<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on teleported.in</title>
    <link>http://teleported.in/posts/</link>
    <description>Recent content in Posts on teleported.in</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Nov 2017 23:27:27 -0400</lastBuildDate>
    
	<atom:link href="http://teleported.in/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Decoding the ResNet architecture</title>
      <link>http://teleported.in/posts/decoding-resnet-architecture/</link>
      <pubDate>Thu, 02 Nov 2017 23:27:27 -0400</pubDate>
      
      <guid>http://teleported.in/posts/decoding-resnet-architecture/</guid>
      <description>Introduction Fast.ai&amp;rsquo;s 2017 batch kicked off on 30th Oct and Jeremy Howard introduced us participants to the ResNet model in the first lecture itself. I had used this model earlier in the passing but got curious to dig into its architecture this time. (In fact in one of my earlier client projects I had used Faster RCNN, which uses a ResNet variant under the hood.)
ResNet was unleashed in 2015 by Kaiming He.</description>
    </item>
    
    <item>
      <title>Network In Network architecture: The beginning of Inception</title>
      <link>http://teleported.in/posts/network-in-network/</link>
      <pubDate>Fri, 20 Oct 2017 23:27:27 -0400</pubDate>
      
      <guid>http://teleported.in/posts/network-in-network/</guid>
      <description>Introduction In this post, I explain the Network In Network paper by Min Lin, Qiang Chen, Shuicheng Yan (2013). This paper was quite influential in that it had a new take on convolutional filter design, which inspired the Inception line of deep architectures from Google.
Motivation Anyone getting introduced to convolutional networks first come across this familiar arrangement of neurons designed by Yann LeCun decades ago:
Fig. LeNet-5</description>
    </item>
    
    <item>
      <title>Analysing AlphaGo</title>
      <link>http://teleported.in/posts/analysing-alphago/</link>
      <pubDate>Fri, 12 May 2017 23:27:27 -0400</pubDate>
      
      <guid>http://teleported.in/posts/analysing-alphago/</guid>
      <description>(I wrote this piece as part of an assignment for Udacity&amp;rsquo;s AI Nanodegree program. The assignment was to summarize the AlphaGo paper in a page)
Introduction Go is a two player, turn taking, deterministic game of perfect information. Two main factors make Go very complex to solve:
 Go has an average branching factor ‘b’ of ~250 options per node (chess ~35) Go has an average depth ‘d’ of ~150 moves (chess ~80)  These factos make the state space of Go (bd) enormous to search end to end using traditional techniques.</description>
    </item>
    
    <item>
      <title>Visualising AI Search Algorithms</title>
      <link>http://teleported.in/posts/ai-search-algorithms/</link>
      <pubDate>Fri, 05 May 2017 23:27:27 -0400</pubDate>
      
      <guid>http://teleported.in/posts/ai-search-algorithms/</guid>
      <description>Search algorithms help find the correct sequence of actions in a search space, to reach a goal state. The sequence of actions might be:
 Sequence in which cities are to be visited to travel from a source to a destination under a given cost function (shortest path, cheapest fare etc.) Sequence in which an agent should play moves in a game (chess, tic tac toe, pacman etc.) to win a board game Sequence in which a robot arm should solder components on a PCB under a given cost function (e.</description>
    </item>
    
  </channel>
</rss>